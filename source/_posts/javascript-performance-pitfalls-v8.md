---
title: V8 中的 JavaScript 性能陷阱
categories: JavaScriptBasic
tags: v8 engine optimization
date: 2021-04-26 00:42:28
---

近年来，JavaScript引擎在各个方面都有所改进。JavaScript的性能已经达到了可以轻松与传统上被认为更适合高性能计算的编程语言竞争的水平。这不仅适用于V8，Chrome和Linux内部的JavaScript引擎Node.js，并且适用于几乎所有主要的JavaScript引擎，包括ChakraCore，Edge的内部的引擎，JavaScriptCore，Safari内部的引擎，以及SpiderMonkey，Firefox内部的引擎。

<!--more-->

不仅峰值性能得到了改善，而且引擎还实现了更一致和可预测的性能水平。鉴于JavaScript是一种高度动态的语言，所有这些性能都基于在引擎中选择正确的启发式算法。JavaScript引擎使用预测优化和内联缓存等技术来加速执行可能的途径。

但是启发式算法也可以很容易对产生您不利，这将帮助您了解他们。所以今天我将分享一些关于v8引擎中两个微妙性能缺陷的背景知识。意识到这些潜在的陷阱可能会帮助您解决问题，如果您更容易踩到这些陷阱的话。

## 优化限制

V8中内置的编译器（TurboFan优化编译器和Ignition节码生成器）是被称为JIT的方法。这意味着编译单位始终是一种方法，也就是JavaScript中的函数。当优化编译器发现热调用站点并通过这样做（通常称为内联）进一步优化的潜力时，它能够包括其他方法的主体。与此相比，使用所谓的跟踪 JIT的其他运行时间 - LuaJIT和PyPy是这里比较流行的示例，其中优化的单位是以前重复执行的连续字节码的任意序列。

在方法JIT和跟踪JIT中，优化器可以处理的输入大小总是有一个上限。对于方法JIT，这个限制自然由函数本身的大小定义。TurboFan也有这样一个限制，目前是60KB字节码（在runtime-profiler.cc中的kMaxBytecodeSizeForOpt常量）-profiler.cc). 也就是说，如果您的函数生成的字节码大于60KB，它们将永远不会被TurboFan优化，即使它们被认为是热的（即经常调用）。

让我们思考一个例子，使用eval动态生成函数(我们故意不在这里使用函数构造器，因为这不允许我们在JavaScript引擎语法上对可以识别的函数的上加上一个名称，这将使研究变得非常具有挑战性）。

```javascript
function generate(n) {
  let s = "(function add" + n + "(x) { return 0";
  for (let i = 0; i < n; ++i) {
    s += "+x";
  }
  s += "; })";
  return eval(s);
}
```

这个generate函数构造了一个新的JavaScript函数对象，将传递给它的参数相加n次。因此，当您调用generate(10)时，您将得到一个如下所示的函数对象：

```javascript
function add10(x) {
  return 0+x+x+x+x+x+x+x+x+x+x;
}
```

现在让我们以上面的一个具体例子来将它运行在NodeJS中:

```javascript
// add10.js

function generate(n) {
  let s = "(function add" + n + "(x) { return 0";
  for (let i = 0; i < n; ++i) {
    s += "+x";
  }
  s += "; })";
  return eval(s);
}

const add10 = generate(10);
add10();
```

查看add10函数生成的字节码，在node shell中使用--print bytecode命令，我们看到如下内容（输出来自NodeJS v10.15）：

``` 
$ node --print-bytecode add10.js
…
[generated bytecode for function: add10]
Parameter count 2
Frame size 8
   19 E> 0x279c523204b2 @    0 : a5                StackCheck
   26 S> 0x279c523204b3 @    1 : 0b                LdaZero
         0x279c523204b4 @    2 : 26 fb             Star r0
         0x279c523204b6 @    4 : 25 02             Ldar a0
   34 E> 0x279c523204b8 @    6 : 34 fb 00          Add r0, [0]
         0x279c523204bb @    9 : 26 fb             Star r0
         0x279c523204bd @   11 : 25 02             Ldar a0
   36 E> 0x279c523204bf @   13 : 34 fb 01          Add r0, [1]
         0x279c523204c2 @   16 : 26 fb             Star r0
         0x279c523204c4 @   18 : 25 02             Ldar a0
   38 E> 0x279c523204c6 @   20 : 34 fb 02          Add r0, [2]
         0x279c523204c9 @   23 : 26 fb             Star r0
         0x279c523204cb @   25 : 25 02             Ldar a0
   40 E> 0x279c523204cd @   27 : 34 fb 03          Add r0, [3]
         0x279c523204d0 @   30 : 26 fb             Star r0
         0x279c523204d2 @   32 : 25 02             Ldar a0
   42 E> 0x279c523204d4 @   34 : 34 fb 04          Add r0, [4]
         0x279c523204d7 @   37 : 26 fb             Star r0
         0x279c523204d9 @   39 : 25 02             Ldar a0
   44 E> 0x279c523204db @   41 : 34 fb 05          Add r0, [5]
         0x279c523204de @   44 : 26 fb             Star r0
         0x279c523204e0 @   46 : 25 02             Ldar a0
   46 E> 0x279c523204e2 @   48 : 34 fb 06          Add r0, [6]
         0x279c523204e5 @   51 : 26 fb             Star r0
         0x279c523204e7 @   53 : 25 02             Ldar a0
   48 E> 0x279c523204e9 @   55 : 34 fb 07          Add r0, [7]
         0x279c523204ec @   58 : 26 fb             Star r0
         0x279c523204ee @   60 : 25 02             Ldar a0
   50 E> 0x279c523204f0 @   62 : 34 fb 08          Add r0, [8]
         0x279c523204f3 @   65 : 26 fb             Star r0
         0x279c523204f5 @   67 : 25 02             Ldar a0
   52 E> 0x279c523204f7 @   69 : 34 fb 09          Add r0, [9]
   55 S> 0x279c523204fa @   72 : a9                Return
Constant pool (size = 0)
Handler Table (size = 0)
…
```

由于NodeJS运行了很多自己的JavaScript，您可能会在这里获得输出页面。搜索短语[generated bytecode for function: add10]，其中下面的字节码转储包含10个加法序列，中间包含Star字节码和Ldar字节码。

除去不相关的部分，我们可以看到具体的字节码输出：

``` 
  0 : a5                StackCheck
  1 : 0b                LdaZero
  2 : 26 fb             Star r0
  4 : 25 02             Ldar a0
  6 : 34 fb 00          Add r0, [0]
  9 : 26 fb             Star r0
 11 : 25 02             Ldar a0
 13 : 34 fb 01          Add r0, [1]
 16 : 26 fb             Star r0
 18 : 25 02             Ldar a0
 20 : 34 fb 02          Add r0, [2]
 23 : 26 fb             Star r0
 25 : 25 02             Ldar a0
 27 : 34 fb 03          Add r0, [3]
 30 : 26 fb             Star r0
 32 : 25 02             Ldar a0
 34 : 34 fb 04          Add r0, [4]
 37 : 26 fb             Star r0
 39 : 25 02             Ldar a0
 41 : 34 fb 05          Add r0, [5]
 44 : 26 fb             Star r0
 46 : 25 02             Ldar a0
 48 : 34 fb 06          Add r0, [6]
 51 : 26 fb             Star r0
 53 : 25 02             Ldar a0
 55 : 34 fb 07          Add r0, [7]
 58 : 26 fb             Star r0
 60 : 25 02             Ldar a0
 62 : 34 fb 08          Add r0, [8]
 65 : 26 fb             Star r0
 67 : 25 02             Ldar a0
 69 : 34 fb 09          Add r0, [9]
 72 : a9                Return
 ```

查看上面的输出，我们看到生成的字节代码为 73 字节大小（72 是字节代码的偏移，该指令的大小为 1 字节）。考虑到我们之前了解到关于TurboFan的60KB极限的情况，这个功能应该可以被TurboFan轻松优化。让我们试着看看如果我们把这个函数放到一个热循环中会发生什么。

```javascript
// add10-optimized.js

function generate(n) {
  let s = "(function add" + n + "(x) { return 0";
  for (let i = 0; i < n; ++i) {
    s += "+x";
  }
  s += "; })";
  return eval(s);
}

const add10 = generate(10);

let result = 0;
for (let i = 0; i < 5 * 1000; ++i) {
  result += add10(i);
}
```

在NodeJS内部运行此代码段，并传递--trace opt命令行参数，我们会看到类似于以下输出的内容：

``` 
$ node --trace-opt add10-optimized.js
[marking 0x32fc83347751 <JSFunction add10 (sfi = 0x32fcde157b91)> for optimized recompilation, reason: small function, ICs with typeinfo: 10/10 (100%), generic ICs: 0/10 (0%)]
[compiling method 0x32fc83347751 <JSFunction add10 (sfi = 0x32fcde157b91)> using TurboFan]
[optimizing 0x32fc83347751 <JSFunction add10 (sfi = 0x32fcde157b91)> - took 0.823, 0.514, 0.016 ms]
[completed optimizing 0x32fc83347751 <JSFunction add10 (sfi = 0x32fcde157b91)>]
```

您可能会看到关于其他正在优化或标记为优化重新编译的函数的消息，请忽略这些消息。有趣的一行是最后一行，它说add10已经被TurboFan成功优化。这符合我们的期望。请注意，每个现代JavaScript引擎都提供此行为。

```javascript
// add10000.js

function generate(n) {
  let s = "(function add" + n + "(x) { return 0";
  for (let i = 0; i < n; ++i) {
    s += "+x";
  }
  s += "; })";
  return eval(s);
}

const add10000 = generate(10 * 1000);

let result = 0;
for (let i = 0; i < 5 * 1000; ++i) {
  result += add10000(i);
}
```

让我们看看如果我们增加生成的函数的大小，使函数的码超字节码超过过TurboFan中的限制会发生什么情况。我们为此示例选择了一个任意数量的10000个加法。然后运行。。。

``` 
node --trace-opt add10000.js
```

没有打印任何东西到控制台，这意味着add10000甚至没有被考虑由TurboFan（有些不幸，V8在这种情况下什么都没说，但只是默默地继续）。实际上，TurboFan甚至没有参与！相反，配置字节码执行的所谓RuntimeProfiler会立即决定函数太大，无法考虑进行优化，并禁用函数优化（在RuntimeProfiler::ShouldOptimize方法中）。

再次使用--print bytecode运行NodeJS，我们看到了罪魁祸首：

``` 
$ node --print-bytecode add10000.js
…
[generated bytecode for function: add10000]
Parameter count 2
Frame size 8
   18 E> 0x2e785b7dcf22 @    0 : a0                StackCheck
   24 S> 0x2e785b7dcf23 @    1 : 0b                LdaZero
         0x2e785b7dcf24 @    2 : 26 fb             Star r0
         0x2e785b7dcf26 @    4 : 25 02             Ldar a0
   32 E> 0x2e785b7dcf28 @    6 : 32 fb 00          Add r0, [0]
         0x2e785b7dcf2b @    9 : 26 fb             Star r0
         0x2e785b7dcf2d @   11 : 25 02             Ldar a0
   34 E> 0x2e785b7dcf2f @   13 : 32 fb 01          Add r0, [1]
…
20026 E> 0x2e785b7f52aa @ 99208 : 00 32 fb ff 0d 27 Add.Wide r0, [9997]
         0x2e785b7f52b0 @ 99214 : 26 fb             Star r0
         0x2e785b7f52b2 @ 99216 : 25 02             Ldar a0
20028 E> 0x2e785b7f52b4 @ 99218 : 00 32 fb ff 0e 27 Add.Wide r0, [9998]
         0x2e785b7f52ba @ 99224 : 26 fb             Star r0
         0x2e785b7f52bc @ 99226 : 25 02             Ldar a0
20030 E> 0x2e785b7f52be @ 99228 : 00 32 fb ff 0f 27 Add.Wide r0, [9999]
20033 S> 0x2e785b7f52c4 @ 99234 : a4                Return
Constant pool (size = 0)
Handler Table (size = 0)
```

函数add10000生成了99235字节的字节码指令。这显然超过了RuntimeProfiler的60KB限制。

## 背景

在v8:8598中有一个关于这个优化极限的讨论。一般来说，总会有某种形式的限制，因为这都是关于引擎的权衡。在V8的例子中，该限制允许TurboFan将各种计数（即中间表示中实体的输入和输出数量）存储为16位整数与32位整数。其他引擎和语言也有类似的限制。例如，在Java中，64KB方法限制甚至是JVM字节码规范的一部分。

## 您可以从本节得到的收获

请确保将大型功能拆分为较小的构建基块。这通常是关于可维护性的好建议，但也有助于JIT正确地优化与应用程序相关的所有内容。较小的函数通常与 JIT 内部的内联机制配合良好，并且通常可以降低编译和优化的成本。想象一下，您有一个更大的函数，可以完成10个不同的任务。即使您只需要1到2个这样的任务，您仍然需要为编译函数中的所有内容支付成本（至少编译成字节码），而且由于内联启发式算法也考虑到了内联函数的大小，这样的函数在热调用站点内联的可能性几乎变得不太可能。

值得指出的是，在编写JavaScript时，通常您不会遇到60KB限制，除非在一些非常极端的情况下。但是以编程方式生成JavaScript的工具（即解析器生成器）非常容易达到这个限制。

## 双字段

V8引擎使用一种称为指针标记的技术来编码任意JavaScript值。这里的技巧是，虽然指针可以用来寻址内存中的任何单个字节，但内存中的JavaScript对象不需要这样做，因为它们通常与字边界对齐（即32位架构上的4字节对齐，64位架构中的8字节对齐）。因此，任何有效对象指针中的最低有效位都是零。V8使用这些位对其他信息进行编码。特别是它使用了两个最不显著的位来区分三种不同的值：

![memory-address](/images/javascript-performance-pitfalls-v8/v8_memory_address.svg)

Smi是31位范围内的一个小整数，即-1073741824和10737418231之间的值，上移一位并在最低有效位中填充0。HeapObject指针是（管理）内存中对象的地址，其中两个最低有效位设置为01。这意味着当V8想要得到对象的真实地址时，它必须从值中减去一个地址。还有WeakHeapObject，它的最低有效位设置为11，本质上类似于HeapObject，只是垃圾收集器对引用的处理很弱。

在本文中，我们只关心Smi和HeapObject。鉴于小整数是JavaScript程序中最常见的数字值，因此有必要对它们进行有效的值编码。这就是为什么有特殊的Smi编码：这样小整数可以有效地存储，例如在对象内部。

```javascript
const a = {
  x: 42,
  y: "Hello"
};
```

考虑一下上面的对象。它有两个属性x和y，x有一个小的整数值，而y有一个字符串值。V8将在内存中表示该对象，如下所示：

![object](/images/javascript-performance-pitfalls-v8/object.svg)

这里a被表示为一个JSObject，它的形态保存了关于a属性的信息，而属性的实际值在实例a中（您可以在我们以前的文章JavaScript引擎基础：形态和内联缓存以及JavaScript引擎基础：优化原型中读到更多关于形态的信息）。由于上面提到的值编码，小整数42可以有效地存储在JSObject内部，而字符串值必须在内存中表示为单独的实体，并由HeapObject指针指向。

现在对于那些看起来很明显并且有意义的字符串，将它们作为单独的实体进行分配，但是其他的数值呢？在JavaScript中，数字是64位双精度浮点值，因此它们可以对31位整数范围之外的许多值进行编码。在V8中使用的基本指针标记方案中，此范围之外的所有数字都必须表示为单独分配的HeapObject实体。

```javascript
const b = {
  x: 2 ** 32,
  y: 1.5
};
```

在上面的b的例子中，我们给x分配了一个整数4294967296，它在31位整数范围之外，给y分配了一个甚至不是整数的数字。这两个值都不能使用有效的Smi编码，因此需要单独的堆分配实体，在V8中称为heapNumber：

![heap_number](/images/javascript-performance-pitfalls-v8/heap_number.svg)

您可以想象，如果应用程序操作的数据结构主要由31位有符号整数范围之外的数值组成（即点、向量等），并且经常更新这些属性的值，那么代价是非常昂贵的。在这种情况下，对这些属性的每次更新都必须分配一个新的HeapNumber实体，因为这些实体本质上是不可变的（因为它们是传递的，因此可以从许多不同的地方引用）。

```javascript
const c = {x: 1.1};
c.x = 1.2;
c.x = 1.3;
```

运行这个简单的代码段将创建三个HeapNumber对象，分别对应于不同的数字1.1、1.2和1.3。

![heap_number_example](/images/javascript-performance-pitfalls-v8/heap_number_example.svg)

总是不得不分配新的HeapNumbers是非常昂贵的，特别是对于数字应用程序，因为它会在垃圾收集器上造成大量的通信，并可能导致不良的缓存位置。

为了缓解在大量具有数字属性的对象上操作的应用程序的这个问题，V8有一个概念称为字段表示跟踪，它跟踪对象中每个字段的值的表示方式。具体来说，V8跟踪一个字段（如一个具体形状所描述的）到目前为止是否一直存储数字，在这里我们区分状态Smi和Double（前者意味着只看到小整数范围内的值，后者意味着也出现了该范围外的其他数字值）。具有Smi表示的字段已经如上所述高被效存储，但是优化编译器TurboFan可以使用字段表示信息来生成更高效的代码（即不需要检查字段是否包含整数，因为从形态上的表示中可以知道）。对于双字段，引入了一个新的MutableHeapNumber实体，该实体看起来像HeapNumber，但绑定到实例绑定并可以就地更新。

```javascript
const c = {x: 1.1};
c.x = 1.2;
c.x = 1.3;
```

再看一下这个被更新的例子，我们发现只需要为double值分配一个存储，并且它刚刚被更新到最新的值：

![heap_number_example_2](/images/javascript-performance-pitfalls-v8/heap_number_example_2.svg)

请注意现在属性信息如何将属性“x”标记为Double字段。

这个优化是由V8引擎完成的，作为一个开发人员，您甚至没有注意到它正在进行。更妙的是，在64位架构上，V8可以使用称为Double字段拆箱的技术将Double值内联存储到实例本身中。我不打算在这里描述这一点，因为其中的细节相当复杂。到目前为止，这应该是自动进行的并且它通常会为您做正确的事。

但它与任何启发式算法一样，都存在权衡。您可能已经在问自己，如何使用JavaScript的动态特性？特别是因为字段可以在任何给定的时间点保存任意值。比如说，如果您决定在某个时刻将一个字符串存储到c.x中呢？

```javascript
c.x = "Hello";
```

这在JavaScript中非常有效，V8通过如下字段表示的表格来处理这一点：

![lattice](/images/javascript-performance-pitfalls-v8/lattice.svg)

对于每个字段，V8将根据存储的值选择最佳的表示形式，并并在必要时通过格子前进。就像将字符串存储到当前具有Double标记的字段中一样，它会将字段前进到标记的表示，这基本上可以说明任何内容。理想情况下，字段应该有Smi、Double或HeapObject表示标记之一（上面用橙色突出显示），也就是说，您不应该混合数字和其他值，以便在大多数情况下获得最佳性能。您可能已经了解了V8中元素种类的概念，这与字段表示机制非常相似。元素种类与数组索引属性有关，而字段表示用于非数组索引属性。

## 混合数字和非数字字段

当您将数字和非数字值都存储到字段中时，它的字段表示肯定会被标记，因为这是同时包含数字和非数字值的字段的唯一有效表示。如果这真的是您想做的，很好。但如果您真的打算操作数字值，那么混入非数值（包括未定义或空的原语）是个不太好的主意。性能方面，如果JavaScript引擎知道某个字段有Smi或Double表示，它可以跳过一系列检查。思考这个简单的例子：

```javascript
function distance(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx * dx + dy * dy);
}
```

计算两点p1和p2之间的距离。如果没有关于字段x和y的表示的任何附加信息，引擎将需要检查四个属性访问p1.x、p2.x、p1.y和p2.y的结果是否都产生了数字（并处理它们没有产生的情况）。

特别是不要用未定义（undefined）或空值（null）预先初始化数字字段，除非您的应用程序有必要这样做。话说回来，别做这种事

```javascript
class Point {
  constructor() {
    this.x = null;
    this.y = null;
  }

  setX(x) { this.x = x; }
  setY(y) { this.y = y; }
}
```

换言之，相比于使用null作为数字字段的初始值，更倾向于实际的数值，例如，可能是0（如果您计划使用小整数）或者0.1甚至NaN（如果您计划使用浮点）。

```javascript
class Point {
  constructor() {
    this.x = 0.1;
    this.y = 0.1;
  }

  setX(x) { this.x = x; }
  setY(y) { this.y = y; }
}
```

## Smi到Double迁移

即使您注意到上面所说的，仍然有另一个微妙的问题，您可能会遇到与数字字段。例如，React团队最近就被这个问题所困扰。这里的微妙问题是，Smi和双字段表示法不兼容：前者要求将数字编码为字段中值的一部分，后者要求将数字存储在专用的MutableHeapNumber实体中。因此，从Smi到Double涉及到一个称为实例迁移的过程，在这个过程中，以前将值存储为Smi的实例需要迁移，以将字段值存储在MutableHeapNumber中。

这个过程包括为实例创建全新的形态，并在引擎命中实例时将实例从旧形态缓慢地迁移到新形态(在迁移开始时停止所有事情并在管理的内存中查找所有实例的代价太高了）。由于形态是在树中组织的（如JavaScript引擎基础：形状和内联缓存中所述），这可能涉及到创建新的形态子树。考虑以下两个对象o1和o2的示例，其中包含Smi字段x和y：

```javascript
const o1 = {};
o1.x = 3;
o1.y = 4;

const o2 = {};
o2.x = 5;
o2.y = 6;
```

这会在以下描述的这些形态之间创建适当的形态和过渡：

![double_shape](/images/javascript-performance-pitfalls-v8/double_shape.svg)

现在想象一下，我们把o2.x的值改为5.5，这不能用这样的Smi来表示：

```javascript
o2.x = 5.5;
```

现在，V8必须从引入属性x的形态开始创建一个全新的子树，并让o2使用新的形态。实例o1仍然指向上一个形态，它现在被标记为已弃用。

![shape_sub_tree](/images/javascript-performance-pitfalls-v8/shape_sub_tree.svg)

如图所示，旧形态子树基本上与根形态断开，取而代之的是一个新的形态子树。旧子树的所有形态都标为弃用，一旦不再有实例使用它们，最终将会被垃圾收集。然而，在此期间，会有额外的开销保持两个单独的元数据树存活。

下次任何IC（内联缓存）看到o1时，它会自动将实例从不推荐使用的形态迁移到其所谓的迁移目标，即新子树中的相应形态。例如，如果您现在执行像o1.y这样的属性访问，它将自动执行自我修复。您甚至不需要储存它，从中加载任何属性就足够了。这也迫使o1.x变成一个Double字段表示，这样之后o1和o2再次使用相同的形状：

![double_field](/images/javascript-performance-pitfalls-v8/double_field.svg)

现在想象一下，当需要对成千上万个拥有大量属性的对象执行此操作时会发生什么情况，这有点类似于facebook/react#14365中的情况，只是在他们的情况下，这是些糟糕的互操作伴随着Object.preventExtensions()在上面，其中V8中的一个bug导致它以某种方式错过了正确的迁移目标，因此V8最终为这个应用程序中的每个FiberNode实例分配了一个新的唯一形态。相关问题v8:8538仍在调查中。

这里给您的可操作建议是，无论何时使用字段来保存任意数字值（包括小整数范围之外的值），请使用非小整数初始化此字段。这样，您就可以从一开始就获得正确的形态，并且可以避免迁移成本（和麻烦）。实现这一点的一个简单方法是在初始化时存储NaN，这也是React对问题的解决方法：


```javascript
class Point {
  constructor(x, y) {
    this.x = NaN; this.x = x;
    this.y = NaN; this.y = y;
  }
}
```

但也像所有性能建议一样：不要到处盲目地这样做。您的许多代码可能都是好的，不会受到性能的影响，即使对象有时会进行迁移。

## 您可以从本节得到的收获

尽量避免混合不同类型的字段值，即不要混合数字、字符串、对象和其他原始值，除非您打算这样做。具体来说，不要将数字字段预初始化为null或undefined，而是选择合理的默认数字（如果有疑问，请使用NaN）。并尝试用小整数范围外的Double值来初始化Double值字段（也就是应该包含小整数范围外的数值的字段），也就是说，如果有疑问，首先在那里输入一个NaN，然后存储实际的初始值。

## 结论

您应该相信 JavaScript 引擎通常会自动为您做正确的事。但与一切一样，了解一些细节是有好处的，所以万一遇到问题，您会找到解决的方法，有时如果启发式算法失败的话，给JavaScript引擎一个额外的提示可能是有益的。

## 附注

- 在撰写本文时，64位架构上的s是32位范围内的整数，但在不久的将来，这可能会改变为在future.Smi的任何地方都使用31位范围内的整数
- 尽管也有JavaScript虚拟机设法存储编码到值本身的短字符串，例如V7嵌入式JavaScript引擎就可以做到这一点。
- 这里的选择是完全武断的，这只是我会这么做的方式，因为它标志着我未来的自我阅读这些代码，我没有不小心的立即地覆盖该值，而是故意这样做的。您可以在这里使用任何非小整数，换言之，NaN 0.1 Number.MAX_VALUE -0可以全部在这里工作。

## 声明

原文：[JavaScript Performance Pitfalls in V8](https://ponyfoo.com/articles/javascript-performance-pitfalls-v8#optimization-limit)

翻译：[SiYuanPub](https://siyuan.pub)
